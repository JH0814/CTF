from pwn import *
from z3 import *
from sage.all import *

context.log_level = 'error'

data = bytes.fromhex("3B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000130000003D0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000010000000C0000003D0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000040000000C0000000C00000036000000360000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000500000000C0000000C0000000C0000000C0000003D000000060000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B00000005000000410000000C0000003D000000360000003D000000120000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000000C0000003D0000000C000000360000000C0000001F000000130000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000004F0000003B0000003B0000003B000000180000000C000000360000000C0000003D000000360000001C0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003E000000540000003B0000003B0000003B0000003B0000003F0000003D000000360000000C0000003D0000003D00000038000000370000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000160000005400000003000000540000003B0000003B0000003B0000003B0000003B0000003B000000510000000C0000003D0000003D0000003D0000003D0000003B0000003B0000003B0000003B0000003B0000003B0000004300000054000000540000005400000054000000440000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000340000003D0000003D0000000C0000003B0000003B0000003B0000003B0000002900000003000000030000005400000003000000320000003C0000003B0000003B0000003B0000003B00000026000000460000003B0000003B0000003B0000003B0000003B000000190000001F0000003B0000003B000000370000005400000054000000540000000300000049000000010000003B0000003B0000003B0000003B0000003B0000003B00000012000000490000002F0000002C0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003D000000420000002F0000000300000054000000540000003F0000003B0000003B0000003B0000003B0000003B00000026000000540000000C0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B00000010000000320000000300000003000000030000005400000041000000400000003B0000003B0000003B00000006000000100000003B0000003B0000003B0000003B0000003B00000027000000310000003B0000003B0000003B0000003B0000003B0000003B0000000D00000032000000420000000300000054000000540000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000001D00000027000000270000004B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000200000003200000054000000490000003B0000003B0000003B0000003B0000003B0000003B00000047000000240000002400000024000000240000004B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000004C000000440000003B0000003B0000003B0000003B0000005300000024000000240000002400000024000000270000004A0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000002200000027000000240000002700000024000000240000000F0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000004D0000002400000024000000240000002400000024000000220000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000004F000000210000001D00000024000000240000002400000024000000090000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B000000140000002400000024000000240000002400000024000000240000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B00000052000000240000002400000024000000240000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000004E00000024000000240000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000003B0000000A000000")
compare = [int.from_bytes(data[i:i+4], 'little') for i in range(0, len(data), 4)]
assert len(compare) == 24*24

key = [ord(c) for c in "C0D3GAT3"]

mod = 0xffff
elf = ELF('./prob')
data = elf.read(0x3220, 0x900)
add_table1 = [int.from_bytes(data[i:i+4], 'little') for i in range(0, 0x900, 4)]
data = elf.read(0x3b20, 0x900)
add_table2 = [int.from_bytes(data[i:i+4], 'little') for i in range(0, 0x900, 4)]
data = elf.read(0x4d20, 0x900)
mul_table = [int.from_bytes(data[i:i+4], 'little') for i in range(0, 0x900, 4)]

arr = [0 for _ in range(576)]
r1 = 0
r2 = 0
for i in range(12):
    if i & 1 != 0:
        arr[24 * (23 - i) + i] = 1
        r1 = 23 - i
        r2 = 24 * i
    else:
        arr[25 * i] = 1
        r1 = 23 - i
        r2 = 24 * r1
    arr[r1 + r2] = 1

def inv_add1(a1, table):
    res = [0 for _ in range(24*24)]
    for i in range(24):
        for j in range(24):
            res[i*24 + j] = (a1[24*i + j] - table[24*i + j]) % 0xffff
    return res

def inv_add2(a1, table):
    res = [0 for _ in range(24*24)]
    for i in range(24):
        for j in range(24):
            res[i*24 + j] = (a1[24*i + j] - table[24*i + j]) & 0xffff
    return res

def right(Y, A):
    Y = [Y[i:i+24] for i in range(0, len(Y), 24)]
    Y = Matrix(IntegerModRing(mod), Y)
    A = [A[i:i+24] for i in range(0, len(A), 24)]
    A = Matrix(IntegerModRing(mod), A)

    X = A.solve_right(Y)
    res = X.list()
    return [ i % mod for i in res ]

def left(Y, A):
    Y = [Y[i:i+24] for i in range(0, len(Y), 24)]
    Y = Matrix(IntegerModRing(mod), Y)
    A = [A[i:i+24] for i in range(0, len(A), 24)]
    A = Matrix(IntegerModRing(mod), A)

    X = A.solve_left(Y)
    res = X.list()
    return [ i % mod for i in res ]

def inv_clockwise(matrix):
    res = matrix[:]
    for i in range(12):
        for j in range(i, 23 - i):
            temp = res[i * 24 + j]
            res[i * 24 + j] = res[j * 24 + (23 - i)]
            res[j * 24 + (23 - i)] = res[(23 - i) * 24 + (23 - j)]
            res[(23 - i) * 24 + (23 - j)] = res[(23 - j) * 24 + i]
            res[(23 - j) * 24 + i] = temp
    return res[:]

def inv_counterclockwise(matrix):
    res = matrix[:]
    for i in range(12):
        for j in range(i, 23 - i):
            temp = res[j * 24 + i]
            res[j * 24 + i] = res[(23 - i) * 24 + j]
            res[(23 - i) * 24 + j] = res[(23 - j) * 24 + (23 - i)]
            res[(23 - j) * 24 + (23 - i)] = res[i * 24 + (23 - j)]
            res[i * 24 + (23 - j)] = temp
    return res[:]


def z3solve(res):
    s = Solver()
    arr_z3 = [0 for _ in range(676)]
    a1 = [Int(f'a{i}') for i in range(484)]
    for var in a1:
        s.add(var >= 0x20)
        s.add(var < 0x7f)
    idx = 0
    for i in range(2, 24):
        for j in range(2, 24):
            arr_z3[26 * i + j] = a1[idx]
            idx += 1
    for i in range(1, 25):
        for j in range(1, 25):
            if arr_z3[26 * i + j] == 0:
                arr_z3[26 * i + j] = key[(i + j - 2) % 8]
    # for i in range(0, 26*26, 26):
    #     print(arr_z3[i:i+26])
    for i in range(24):
        for j in range(24):
            form = (
                arr_z3[26 * (i+2) + j+2] +
                arr_z3[26 * (i+2) + j+1] +
                arr_z3[26 * (i+2) + j+0] +
                arr_z3[26 * (i+1) + j+2] +
                arr_z3[26 * (i+1) + j+1] +
                arr_z3[26 * (i+1) + j+0] +
                arr_z3[26 * (i+0) + j+2] +
                arr_z3[26 * (i+0) + j+1] +
                arr_z3[26 * (i+0) + j+0]
            ) % 0x100000000
            # print(form)
            s.add(res[24 * i + j] == form)
    assert s.check() == sat
    m = s.model()
    return [m[a1[i]].as_long() for i in range(484)]

res = inv_add2(compare, add_table2)
res = left(res, mul_table)
res = inv_add1(res, add_table1)
res = inv_counterclockwise(res)
res = right(res, arr[:])
res = left(res, arr[:])
res = inv_clockwise(res)
# print(res)
flag = z3solve(res)
print(''.join(chr(i) for i in flag))